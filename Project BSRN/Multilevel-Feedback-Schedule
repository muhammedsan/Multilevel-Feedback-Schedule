import argparse
import logging
import sys
import matplotlib.pyplot as plt

# Parser für Befehlszeilenargument erstellen
parser = argparse.ArgumentParser(description= 'Prozessverwaltung')

# Argumente definieren
parser.add_argument('-warteschlangen', type=int,required =False, help='Anzahl der Warteschlangen')
parser.add_argument('-quantum', type=int, nargs='+', required=False, help='Gebe Zeitquanten für jede Warteschlange an')
parser.add_argument('-processlistfile', type=str, help='Der Dateiname der Prozessliste')
parser.add_argument('-logdatei', type=str, help='Der Name der Logdatei')
parser.add_argument('-ausgabedatei', type=str, help='Der Name Ausgabedatei')
parser.add_argument('-ausgabeformat', type=str, choices=['text', 'grafisch'], help='Das Ausgabeformat text oder grafisch')

# Argumente auswerfen 
args = parser.parse_args()

# Dateipfad aus den Argumenten auslesen
process_list_file = args.processlistfile

# Kommandozeilenagrumente werden überprüft
def pruefe_argumente (args):
   if args.warteschlangen is not None:
       if args.warteschlangen <= 0:
           print("Fehler: Die Anzahl der Warteschlangen muss größer als 0 sein")
           return False
       
   if args.quantum is not None:
       if any(q <= 0 for q in args.quantum):
           print("Fehler: Alle Zeitquanten müssen größer als 0 sein")        
           return False
       
   if args.warteschlangen and len(args.quantum) != args.warteschlangen:
       print("Fehler: Die Anzahl der Zeitquanten muss der Anzahl der Warteschlangen entsprechen")
       return False
   return True
        
# Argumente wurden validiert und akzeptiert    
if pruefe_argumente(args):      
    anzahlWS = args.warteschlangen
    quantum = args.quantum

# Interaktive Benutzeringabe falls Z.43 False
else:
    anzahlWS = int(input('Gebe die Anzahl der Warteschlangen an: '))
    while anzahlWS <= 0:
        print("Die Anzahl der Warteschlangen muss größer als 0 sein")
        anzahlWS = int(input('Gebe die Anzahl der Warteschlangen an'))
        
    zeitquanten = []
    for i in range(anzahlWS):
        quantum = int(input(f'Gebe das Zeitquantum für Warteschlange {i+1} an:'))
        while quantum <= 0:
            print("Das Zeitquantum muss größer als 0 sein")
            quantum = int(input(f'Gebe das Zeitquantum für Warteschlange {i+1} an:'))
        zeitquanten.append(quantum)
                
# Eingaben überprüfen 
print("\nÜberprüfen Sie Ihre Eingaben: ")
print(f"Anzahl der Warteschlangen: {args.warteschlangen}")
print(f"Quanten: {args.quantum}")
print(f"Prozessliste: {args.processlistfile}")
print(f"Logdatei: {args.logdatei}")
print(f"Ausgabedatei: {args.ausgabedatei}")
print(f"Ausgabeformat: {args.ausgabeformat}")
          
# Print Ausgabe, wenn interaktive Benutzereingabe genutzt wurde
print('Anzahl der Warteschlangen:', anzahlWS)
print('Zeitquantum: ',zeitquanten)
print(f'Verwendeter Dateipfad: {process_list_file}')


# Methode zum Einlesen der Prozesse
def lese_prozess_list(dateiname):
    prozesse = []
    try:
       with open(dateiname, 'r') as file:
           for line in file:
               parts = line.strip().split(',')
               if len(parts) == 3:  
                   # Dictionary 
                   prozess = {
                       'name': parts[0],
                       'cpu_time': int(parts[1]),
                       'ankunftszeit': int(parts[2])
                }
               prozesse.append(prozess)
    except FileNotFoundError:
        print(f'Fehler: Die Datei {dateiname} wurde nicht gefunden.')
        return []
    except Exception as e:
        print(f'Ein Fehler ist aufgetreten: {e}')
        return []
    return prozesse   

# P aus der Datei lesen
prozess_liste = lese_prozess_list(process_list_file)

# Grundkonfiguration Logdatei
logging.basicConfig(filename=args.logdatei, level=logging.INFO, format='%(asctime)s - %(message)s')

# Start Multilevel-Feedback-Schedule
scheduling_warteschlangen = list(zip(zeitquanten, [[] for _ in range(anzahlWS)]))
laufzeit = {prozess['name']: 0 for prozess in prozess_liste}  # Anfangslaufzeit = 0
gesamt_wartezeit = {prozess['name']: 0 for prozess in prozess_liste}      
zeit = 0 

# Alle P werden in die erste WS eingefügt
for prozess in prozess_liste:
    scheduling_warteschlangen[0][1].append(prozess) # P wird in die erste WS eingefügt
    
# Simulation
def round_robin_algorithmus(scheduling_warteschlangen, quantum):
    
    i = 0
    while i < len(scheduling_warteschlangen):
        quantum, warteschlange = scheduling_warteschlangen[i]
        while warteschlange: # Vearbeitet die aktuelle Warteschlange
             prozess = warteschlange.pop(0)
             cpu_zeit_vorher = prozess['cpu_time'] 
             prozess['cpu_time'] -= min(quantum, prozess['cpu_time']) # CPU Zeit wird um ZQ reduziert
             ausführungs_zeit = cpu_zeit_vorher - prozess['cpu_time'] 
             zeit += ausführungs_zeit 
             
     
             # Startsignal 
             logging.info(f"Prozess {prozess['name']} wird bearbeitet")
             print(f"Prozess {prozess['name']} wird bearbeitet")
    
    
             # Protokollierung nach der Bearbeitung
             logging.info(f"Prozess {prozess['name']} bearbeitet für {ausführungs_zeit} Sekunden. Verbleibende CPU-Zeit: {prozess['cpu_time']}")
             print(f"Prozess {prozess['name']} bearbeitet für {ausführungs_zeit} Sekunden. Verbleibende CPU-Zeit: {prozess['cpu_time']}")
            
            
             # Überprüfen, ob der P noch CPU-Zeit hat     
             if prozess['cpu_time'] > 0: 
                  print(f"{prozess['name']} benötigt noch {prozess['cpu_time']} Sekunden")
          
                  if i < len(scheduling_warteschlangen) -1: # Überprüfen, ob P sich nicht in der letzten WS befindet
                      scheduling_warteschlangen[i+1][1].append(prozess) # P wird in die nächste WS eingereiht
              
                  else: 
                      warteschlange.append(prozess) # Ansonsten bleibt P in der tiefsten WS drin  
    else:
            # CPU Laufzeit auf 0 setzen 
            prozess['cpu_time'] = 0 
            print(f'Prozess {prozess['name']} abgeschlossen.') 
            logging.info(f"Prozess {prozess['name']} abgeschlossen.")
                         
print('Zusammenfassung der Prozessdaten:')
for prozess in prozess_liste:
    print(f"Prozess: {prozess['name']}, CPU Zeit: {prozess['cpu_time']}, Ankunftszeit: {prozess['ankunftszeit']}, 
          Laufzeit: {laufzeit}, Wartezeit: {gesamt_wartezeit}, Gesamtzeit: {zeit} Sekunden")

prozess_liste = lese_prozess_list(args.processlistfile)

# Gantt-Diagramm
fig, achse = plt.subplots()

# Berechnen der maximalen Zeit, für die X Achse
max_zeit = max(prozess['ankunftszeit'] + prozess['cpu_time'] for prozess in prozess_liste)

for i, prozess in enumerate(prozess_liste) :
    achse.barh(y = i, width = prozess['cpu_time'], left = prozess['ankunftszeit'], color = "green")

# Diagrammtitel
plt.title("Gantt-Diagramm der Prozessverarbeitung") 

# X - Achsenbeschriftungen und Ticks setzen
achse.set_xlabel('Zeit')
achse.set_xticks(range(0,max_zeit+1))
achse.set_xticklabels(0,max_zeit)

# Y - Achsenbeschriftungen und Ticks setzen
achse.set_ylabel('Prozesse')
achse.set_yticks(range(len(prozess_liste)))
achse.set_yticklabels([prozess['name']  for prozess in prozess_liste])

# Gitterlinien hinzufügen
achse.grid(True,linestyle = '-', linewidth=0.5)

# Diagramm anzeigen
plt.tight_layout()
plt.show()


# Öffnen der Ausgabedatei 
with open(args.ausgabedatei, 'w') as f: 
   # Print der wichtigsten Informationen in die Ausgabedatei
   f.write('Anzahl der Warteschlangen: {anzahlWS}\n') 
   f.write('Zeitquanten: {zeitquanten}\n')
   
   # Laufzeit fehlt
   # Wartezeiten fehlt
   # durchschnittliche Laufzeit fehlt
   # durchschnittliche Wartezeit fehlt

print(f"Name der Ausgabedatei: {args.ausgabedatei}")




