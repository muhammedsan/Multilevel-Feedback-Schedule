import argparse
import logging
import matplotlib.pyplot as plt


# Prozess / Parser
prozess_parser = argparse.ArgumentParser(description= 'Prozesse einlesen')
prozess_parser.add_argument('-processlistfile', type=str, required=True,help ='Geben Sie den Pfad zur Prozessliste an')
prozess_parser.add_argument('-warteschlangen' , type=int, required=False, help = 'Anzahl der Warteschlangen')
prozess_parser.add_argument('-quantum', type=int, nargs='+', required=False, help='Liste von Zeitquanten für jede Warteschlange')
prozess_args = prozess_parser.parse_args()

# Ausgabedatei/ Parser
ausgabe_parser=argparse.ArgumentParser(description='Ausgabedatei: Name& Pfad')
ausgabe_parser.add_argument('dateiname',type=str, required=False, help='Geben Sie den Namen für die Ausgabedatei an')
ausgabe_parser.add_argument('dateipfad',type=str, help='Geben Sie den Pfad für die Ausgabedatei an')
ausgabe_args = ausgabe_parser.parse_args()

# Logdatei/ Parser
log_parser = argparse.ArgumentParser(description='Logdatei konfigurieren')
log_parser.add_argument('logdatei', type=str,required=True,help='Geben Sie den Namen der Logdatei an' )
log_parser.add_argument('logdateipfad',type=str, required=True, help='Geben Sie einen Pfad für die Logdatei an')
log_args = log_parser.parse_args()


# Dateipfad aus den Argumenten auslesen
process_list_file = prozess_args.processlistfile


# per Kommandozeilenargumente, wenn vorhanden
if prozess_args.warteschlangen is not None and prozess_args.quantum is not None:
     anzahlWS = prozess_args.warteschlangen
     quantum = prozess_args.quantum
else:
    # Interaktive Benutzereingabe, wenn Kommandozentrale leer
    while True: 
     try:
          anzahlWS = int(input('Gebe die Anzahl der Warteschlangen an: '))
          if anzahlWS <= 0: 
             raise ValueError('Die Anzahl der Warteschlange muss größer als 0 sein')
          break # Verlässt die Schleife nur bei gültiger Eingabe
     except ValueError as e: 
         print(e)
        
        
    zeitquanten = []
    for i in range(anzahlWS):
        while True:
            try:
                quantum = int(input(f'Gebe das Zeitquantum für Warteschlange {i+1} an:'))
                if quantum <= 0:
                    raise ValueError('Das Zeitquantum muss größer als 0 sein')
                zeitquanten.append(quantum)
                break
            except ValueError as e:
                print(e)
                
                
# Print Ausgabe
print('Anzahl der Warteschlangen:', anzahlWS)
print('Zeitquantum: ',zeitquanten)
print(f'Verwendeter Dateipfad: {process_list_file}')


# Methode zum Einlesen der Prozesse
def lese_prozess_list(dateiname):
    prozesse = []
    try:
       with open(dateiname, 'r') as file:
           for line in file:
               parts = line.strip().split(',')
               if len(parts) == 3:  
                   # Dictionary 
                   prozess = {
                       'name': parts[0],
                       'cpu_time': int(parts[1]),
                       'ankunftszeit': int(parts[2])
                }
               prozesse.append(prozess)
    except FileNotFoundError:
        print(f'Fehler: Die Datei {dateiname} wurde nicht gefunden.')
        return []
    except Exception as e:
        print(f'Ein Fehler ist aufgetreten: {e}')
        return []
    return prozesse   

# Prozesse aus der Datei lesen
prozess_liste = lese_prozess_list(process_list_file)
                        
# Öffnen der Logdatei                                  
logdatei = open("logdatei.txt", "w") 

# Grundkonfiguration Logdatei
logging.basicConfig(filename=log_args.logdatei, level=logging.INFO, format='%(asctime)s - %(message)s')

# Start Multilevel-Feedback-Schedule
laufzeit = {prozess['name']: 0 for prozess in prozess_liste}       
gesamt_wartezeit = {prozess['name']: 0 for prozess in prozess_liste}      
warteschlangen = [[] for _ in range(anzahlWS)]   
startzeiten = {prozess['name']: None for prozess in prozess_liste} 
zeit = 0

# Prozesse in WS1 hinzugefügt
for prozess in prozess_liste:
    warteschlangen[0].append(prozess)
    
# Simulation
i = 0
while i < len(warteschlangen):
    while warteschlangen[i]:
        prozess = warteschlangen[i].pop(0)
        
        if startzeiten [prozess['name']] is None:
            startzeiten[prozess['name']] = zeit
            
            cpu_zeit_vorher = prozess['cpu_time']
            prozess['cpu_time'] -= zeitquanten[i] # CPU Zeit wird um Zeitquantum reduziert
            ausführungs_zeit = min(zeitquanten[i], cpu_zeit_vorher) 
            zeit += ausführungs_zeit # Aktuelle Zeit wird aktualisiert
            
            logging.info(f'Prozess {prozess['name']} wird bearbeitet')
            print(f"Prozess {prozess['name']} wird bearbeitet")
            

        if prozess['cpu_time'] > 0: # Überprüfen, ob der Prozess noch CPU-Zeit hat
            if i < len(warteschlangen) -1: # Wenn ja, füge Prozess in die nächste Warteschlange ein
                warteschlangen[i+1].append(prozess) 
                
                print(f"Prozess = {prozess['name']} ist jetzt in der {i + 2} Warteschlange!")
                logdatei.info(f"Prozess {prozess ['name']} ist jetzt in der {i + 2} Warteschlange!")
                print(f"Prozessdaten: Name = {prozess['name']}, Verbleibende CPU-Zeit = {prozess['name']}")
                
            else:
                warteschlangen[i].append(prozess)  # Prozess bleibt in der tiefsten Warteschlange
                
        else:
            laufzeit[prozess['name']] = zeit - startzeiten[prozess['name']] # Gesamte Laufzeit
            
            # CPU Laufzeit auf 0 setzen 
            prozess['cpu_time'] = 0 
            aktuelle_cpu_time = prozess['cpu_time']
            
            print(f"Prozess {prozess['name']} abgeschlossen.") 
            logdatei.info(f"Prozess {['name']} abgeschlossen.")
            
            print(f"Prozessdaten: Name = {prozess['name']}, Verbleibende CPU-Zeit = {aktuelle_cpu_time}")
            
            for j in range(len(warteschlangen)):
                for prozess_in_warteschlange in warteschlangen[j]:
                    if prozess_in_warteschlange['name'] != prozess['name']:
                        gesamt_wartezeit[prozess_in_warteschlange['name']] += ausführungs_zeit
                        
            for prozess in prozess_liste:
                gesamte_zeit = laufzeit[prozess['name']] + gesamt_wartezeit[prozess['name']]
            
    i += 1

# Ausgabe der Daten
for prozess in prozess_liste:
    print(f"Prozess: {prozess['name']}, Laufzeit = {laufzeit[prozess['name']]}, Wartezeit = {gesamt_wartezeit[prozess['name']]}")


prozess_liste = lese_prozess_list(prozess_args.processlistfile)


# Gantt-Diagramm
fig, achse = plt.subplots()

# Berechnen der maximalen Zeit, für die X Achse
max_zeit = max(prozess['ankunftszeit'] + prozess['cpu_time'] for prozess in prozess_liste)


for i, prozess in enumerate(prozess_liste) :
    achse.barh(y = i, width = prozess['cpu_time'], left = prozess['ankunftszeit'], color = "green")

# Labels geändert und ticks gesetzt zur anordnung von cpu laufzeit und ankunftszeit
# Diagrammtitel
plt.title("Gantt-Diagramm der Prozessverarbeitung") 

# X - Achsenbeschriftungen und Ticks setzen
achse.set_xlabel("Zeit")
achse.set_xticks(range(0,max_zeit+1))
achse.set_xticklabels(0,max_zeit)

# Y - Achsenbeschriftungen und Ticks setzen
achse.set_ylabel("Prozesse")
achse.set_yticks(range(len(prozess_liste)))
achse.set_yticklabels([prozess['name']  for prozess in prozess_liste])

# Gitterlinien hinzufügen
achse.grid(True,linestyle = '-', linewidth=0.5)

# Diagramm anzeigen
plt.tight_layout()
plt.show()




# Fehlerbehebung Logdatei
# Überprüfen, ob Logdateiargument vorhanden ist 
if log_args.logdatei: 
    logdatei = log_args.logdatei 
    # Überprüfen, ob ".log" im Dateinamen ist 
    if not logdatei.endswith(".log"):
        logdatei += ".log"
else: logdatei = input("Geben Sie einen Namen für die Logdatei an")
if not logdatei.endswith(".log"):
    logdatei += ".log"

# Überprüfen, ob Logdateipfad vorhanden ist 
if log_args.logdateipfad: 
    logdateipfad = log_args.logdateipfad
else: logdateipfad = input("Geben Sie den Pfad für die Logdatei an")

# Öffnen der Ausgabedatei 
with open(ausgabe_args.dateiname, 'w') as f: 
   # Print der wichtigsten Informationen in die Ausgabedatei
   f.write('Anzahl der Warteschlangen: '+anzahlWS)
   f.write('Zeitquanten: '+zeitquanten)

print(f"Name der Ausgabedatei: {ausgabe_args.dateiname}")
print(f"Pfad der Ausgabedatei: {ausgabe_args.dateipfad}")



